// Простой тест типизированных макросов

struct User {
    name: string,
    age: int
}

struct Product {
    title: string,
    price: float
}

enum Status {
    ACTIVE,
    INACTIVE
}

// Макрос, принимающий любой тип
macro analyzeAnyType(typeParam: Type) {
    println("=== Universal Analysis ===")
    println("Type: " + typeParam.Name)
    println("Kind: " + typeParam.Kind)
}

// Макрос только для структур
macro structOnly(structParam: StructType) {
    println("=== Struct Only ===")
    println("Processing struct: " + structParam.Name)
    
    Expr {
        println("fn create" + structParam.Name + "() { return {} }")
    }
}

// Макрос только для enum
macro enumOnly(enumParam: EnumType) {
    println("=== Enum Only ===")
    println("Processing enum: " + enumParam.Name)
    
    Expr {
        println("fn get" + enumParam.Name + "Values() { return [] }")
    }
}

println("=== Testing Typed Macros ===")

println("")
println("✨ НОВЫЙ СИНТАКСИС: прямое указание типов! ✨")

println("1. Universal analyzer:")
@analyzeAnyType(User)        // @macro(TypeName) напрямую!
@analyzeAnyType(int)         // Примитивные типы тоже работают!
@analyzeAnyType(Status)      // Енумы тоже!

println("")
println("2. Struct-only macro:")
@structOnly(User)            // Только структуры
@structOnly(Product)         // Работает с любыми структурами

println("")
println("3. Enum-only macro:")
@enumOnly(Status)            // Только енумы

println("")
println("4. Testing type constraint violation:")
// Следующая строка должна вызвать ошибку если раскомментировать:
// @structOnly(int)  // Ошибка: expected struct type, got primitive

println("")
println("=== Tests completed! ===")