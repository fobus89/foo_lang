// Демонстрация работы макросов в foo_lang

// Простой макрос для отладки
macro debug(expr) {
    println("DEBUG: " + expr)
    println("Value: " + expr)
}

// Макрос для создания геттера и сеттера
macro property(name, dataType) {
    let privateValue = nil
    
    fn getName() {
        return privateValue
    }
    
    fn setName(value) {
        privateValue = value
    }
}

// Макрос для измерения времени выполнения (пока упрощенный)
macro timing(name, code) {
    println("Starting: " + name)
    code
    println("Finished: " + name)
}

// Макрос для проверки условий
macro assert(condition, message) {
    if !condition {
        println("ASSERTION FAILED: " + message)
    }
}

// Использование макросов
println("=== Тестирование макросов ===")

// 1. Простой debug макрос
let x = 10
@debug(x * 2)

// 2. Assert макрос
@assert(x > 0, "x должен быть положительным")
@assert(x < 5, "x должен быть меньше 5")

// 3. Timing макрос  
fn simpleCalculation(n) {
    return n * 2 + 1
}

let result = simpleCalculation(5)
@timing("простое вычисление", result)

// 4. Property макрос (упрощенная версия)
// @property(age, int)
// setAge(25)
// println("Age: " + getAge())

println("\n=== Макросы с quote/unquote ===")

// Макрос для создания функции удвоения (упрощенная версия)
macro makeDouble(value) {
    println("Doubled value: " + (value * 2))
}

// Использование
@makeDouble(5)

// Более сложный пример - макрос для создания switch-like конструкции
macro switch(value, cases) {
    let matched = false
    // В реальной реализации здесь была бы манипуляция с AST
    // для создания цепочки if-else из cases
}

println("\nМакросы успешно протестированы!")