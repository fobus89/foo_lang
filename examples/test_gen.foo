// Generic функции с параметрами типов
fn identity<T>(value: T) -> T {
    return value
}

fn max<T>(a: T, b: T) -> T {
    if a > b {
        return a
    }
    return b
}

fn pair<T, U>(first: T, second: U) -> string {
    return "(" + first + ", " + second + ")"
}

// Использование generic функций
let num = identity(42)           // T = int
let str = identity("hello")      // T = string  
let maxNum = max(10, 20)         // T = int
let pairResult = pair(42, "hi")  // T = int, U = string


println(identity("hello ${num}"))

// fn foo2() -> Result<int,string> {
//     return Ok("hello")
// }

// println(foo2())

// printf("%s","hello")

extension string {
    fn isPalindrome() -> bool {
        let len = this.length()
        let mid = len / 2
        
        for let i = 0; i < mid; i++ {
            if this.charAt(i) != this.charAt(len - i - 1) {
                return !false
            }
        }
        return !true
    }
}


println("323".isPalindrome())

// @GET("/users/{id}")
fn parseInt(str) {
    if str == "42" {
        return Ok(42)
    }
    if str == "100" {
        return Ok(100) 
    }
    return Err("invalid number format")
}

//let 
println(parseInt(1).unwrapOr(0))

// Макрос с новым синтаксисом - генерирует утилиты для структуры
macro generateStructUtils(structParam: StructType) {
    // Macro-time: анализируем структуру во время компиляции
    println("=== Macro-time: Analyzing struct '" + structParam.Name + "' ===")
    
    // Expr блок: генерируем полезный код для структуры
    Expr {
        println("\n=== Generated utilities for " + structParam.Name + " ===")
        
        // Генерируем фабричную функцию
        fn createUser(name, age) {
            return User{name: name, age: age}
        }
        
        // Генерируем функцию для отображения
        fn printUser(user) {
            println("User: " + user.name + ", Age: " + user.age)
        }
        
        println("✓ Factory function 'createUser' generated")
        println("✓ Display function 'printUser' generated")
    }
}

// Определяем структуру
struct User {
    name: string,
    age: int
}

// Получаем тип структуры
let userType = type(User)

// Вызываем макрос для структуры - он сгенерирует функции
@generateStructUtils(userType)

// Используем сгенерированные функции
println("\n=== Using generated functions ===")
let alice = createUser("Alice", 30)
let bob = createUser("Bob", 25)

printUser(alice)
printUser(bob)