// –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ –≤ –¥—É—Ö–µ Rust
// üî• –ù–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞: Result<T, E> —Ç–∏–ø—ã –≤–º–µ—Å—Ç–æ panic()

println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ ===\n")

// === 1. –ë–ï–ó–û–ü–ê–°–ù–´–ô –î–û–°–¢–£–ü –ö –ú–ê–°–°–ò–í–ê–ú ===
println("1. –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ –º–∞—Å—Å–∏–≤–∞–º:")

let numbers = [1, 2, 3, 4, 5]
println("Array: " + numbers)

// –ù–æ—Ä–º–∞–ª—å–Ω—ã–π –¥–æ—Å—Ç—É–ø
let result1 = numbers[2]  // –î–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å Ok(3)
if result1.isOk() {
    println("numbers[2] = " + result1.unwrap())
} else {
    println("Error accessing numbers[2]")
}

// –î–æ—Å—Ç—É–ø –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã –º–∞—Å—Å–∏–≤–∞
let result2 = numbers[10] // –î–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å Err(IndexError)
if result2.isErr() {
    println("numbers[10] failed as expected: " + result2.unwrapOr("INDEX_ERROR"))
} else {
    println("numbers[10] = " + result2.unwrap())
}

// === 2. –ë–ï–ó–û–ü–ê–°–ù–ê–Ø –†–ê–ë–û–¢–ê –° –§–£–ù–ö–¶–ò–Ø–ú–ò ===
println("\n2. –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å —Ñ—É–Ω–∫—Ü–∏—è–º–∏:")

// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–µ–ª–µ–Ω–∏—è
fn safeDivide(a, b) {
    if b == 0 {
        return Err("Division by zero")
    }
    return Ok(a / b)
}

let divResult1 = safeDivide(10, 2)
if divResult1.isOk() {
    println("10 / 2 = " + divResult1.unwrap())
} else {
    println("Division failed: " + divResult1.unwrapOr("ERROR"))
}

let divResult2 = safeDivide(10, 0)
if divResult2.isErr() {
    println("10 / 0 failed as expected: " + divResult2.unwrapOr("DIVISION_ERROR"))
}

// === 3. –û–ë–†–ê–ë–û–¢–ö–ê –û–®–ò–ë–û–ö –° MATCH ===
println("\n3. –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ —Å match:")

fn processValue(value) {
    if value > 0 {
        return Ok("Positive: " + value.toString())
    } else if value == 0 {
        return Err("Zero is not allowed")
    } else {
        return Err("Negative numbers not supported")
    }
}

let values = [5, 0, -3]
for let i = 0; i < values.length(); i++ {
    let val = values[i]
    let result = processValue(val)
    
    if result.isOk() {
        println("Success: " + result.unwrap())
    } else {
        println("Error: " + result.unwrapOr("UNKNOWN_ERROR"))
    }
}

// === 4. –¶–ï–ü–û–ß–ö–ò –û–ë–†–ê–ë–û–¢–ö–ò –û–®–ò–ë–û–ö ===
println("\n4. –¶–µ–ø–æ—á–∫–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫:")

fn validateAge(age) {
    if age < 0 {
        return Err("Age cannot be negative")
    }
    if age > 150 {
        return Err("Age too high")
    }
    return Ok(age)
}

fn calculateBirthYear(age) {
    let validAge = validateAge(age)
    if validAge.isErr() {
        return validAge  // –ü–µ—Ä–µ–¥–∞–µ–º –æ—à–∏–±–∫—É –¥–∞–ª—å—à–µ
    }
    
    let currentYear = 2025
    let birthYear = currentYear - validAge.unwrap()
    return Ok(birthYear)
}

let ages = [25, -5, 200, 30]
for let i = 0; i < ages.length(); i++ {
    let age = ages[i]
    let birthYearResult = calculateBirthYear(age)
    if birthYearResult.isOk() {
        println("Age " + age + " -> Birth year: " + birthYearResult.unwrap())
    } else {
        println("Age " + age + " -> Error: " + birthYearResult.unwrapOr("VALIDATION_ERROR"))
    }
}

// === 5. –ö–û–ú–ë–ò–ù–ò–†–û–í–ê–ù–ò–ï –†–ï–ó–£–õ–¨–¢–ê–¢–û–í ===
println("\n5. –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:")

fn combineResults(result1, result2) {
    if result1.isErr() {
        return result1
    }
    if result2.isErr() {
        return result2
    }
    
    let combined = [result1.unwrap(), result2.unwrap()]
    return Ok(combined)
}

let r1 = Ok(42)
let r2 = Ok("hello")
let r3 = Err("failure")

let combined1 = combineResults(r1, r2)
if combined1.isOk() {
    println("Combined success: " + combined1.unwrap())
}

let combined2 = combineResults(r1, r3)
if combined2.isErr() {
    println("Combined error: " + combined2.unwrapOr("COMBINE_ERROR"))
}

// === 6. –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ï unwrapOr –î–õ–Ø –ó–ù–ê–ß–ï–ù–ò–ô –ü–û –£–ú–û–õ–ß–ê–ù–ò–Æ ===
println("\n6. –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é:")

fn getConfigValue(key) {
    let config = {
        "host": "localhost",
        "port": "8080"
    }
    
    if config[key] {
        return Ok(config[key])
    } else {
        return Err("Key not found: " + key)
    }
}

let host = getConfigValue("host").unwrapOr("default-host")
let timeout = getConfigValue("timeout").unwrapOr("30")
let invalid = getConfigValue("invalid").unwrapOr("fallback-value")

println("Host: " + host)
println("Timeout: " + timeout) 
println("Invalid key: " + invalid)

// === 7. –û–ë–†–ê–ë–û–¢–ö–ê –û–®–ò–ë–û–ö –í ASYNC –§–£–ù–ö–¶–ò–Ø–• ===
println("\n7. Async –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫:")

fn asyncOperation(shouldFail) {
    await sleep(10)  // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
    
    if shouldFail {
        return Err("Async operation failed")
    } else {
        return Ok("Async success")
    }
}

// –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ async –æ–ø–µ—Ä–∞—Ü–∏–π
let asyncTasks = [
    async asyncOperation(false),
    async asyncOperation(true),
    async asyncOperation(false)
]

for let i = 0; i < asyncTasks.length(); i++ {
    let task = asyncTasks[i]
    let result = await task
    if result.isOk() {
        println("Task " + i + " succeeded: " + result.unwrap())
    } else {
        println("Task " + i + " failed: " + result.unwrapOr("ASYNC_ERROR"))
    }
}

println("\n=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ ===")
println("üéâ –ù–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫:")
println("‚úÖ Result<T, E> —Ç–∏–ø—ã –≤–º–µ—Å—Ç–æ panic()")
println("‚úÖ –î–µ—Ç–∞–ª—å–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º")
println("‚úÖ Stack traces –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏")  
println("‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Ç–∏–ø–æ–≤")
println("‚úÖ –¶–µ–ø–æ—á–∫–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫")
println("‚úÖ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å async/await")