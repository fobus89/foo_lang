package main

import (
	"fmt"
	"foo_lang/ast"
	"foo_lang/builtin"
	"foo_lang/modules"
	"foo_lang/parser"
	"os"
	"strings"
)

type User struct {
	Id   int    `json:"id"`
	Name string `json:"name"`
}

func main() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(err)
		}
	}()

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–ª–∞–≥ bytecode —Ä–µ–∂–∏–º–∞
	for _, arg := range os.Args {
		if arg == "--bytecode" || arg == "-b" {
			RunBytecodeMode()
			return
		}
		if arg == "--help" || arg == "-h" {
			printUsage()
			return
		}
	}

	var filename string = "examples/main.foo" // –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

	if len(os.Args) > 1 {
		// –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ñ–ª–∞–≥–∏ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ —Ñ–∞–π–ª–∞
		for _, arg := range os.Args[1:] {
			if !strings.HasPrefix(arg, "-") {
				filename = arg
				break
			}
		}
	}

	// Set up global parse function for module imports
	parseFunc := func(code string) []modules.Expr {
		// –î–ª—è –º–æ–¥—É–ª–µ–π –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –ø–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç GlobalScope
		exprs := parser.NewParser(code).ParseWithoutScopeInit()
		result := make([]modules.Expr, len(exprs))
		for i, expr := range exprs {
			result[i] = expr
		}
		return result
	}
	ast.SetGlobalParseFunc(parseFunc)

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º NewParserFromFile –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è API
	p, err := parser.NewParserFromFile(filename)
	if err != nil {
		fmt.Printf("Error creating parser: %v\n", err)
		return
	}
	
	// –ü–æ–ª—É—á–∞–µ–º scope –∏–∑ –ø–∞—Ä—Å–µ—Ä–∞ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
	scopeStack := p.GetScopeStack()
	
	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Å —ç—Ç–∏–º scope
	builtin.InitializeMathFunctions(scopeStack)
	builtin.InitializeStringFunctions(scopeStack)
	builtin.InitializeFilesystemFunctions(scopeStack)
	builtin.InitializeHttpFunctions(scopeStack)
	builtin.InitializeChannelFunctions(scopeStack)
	builtin.InitializeTimeFunctions(scopeStack)
	builtin.InitializeCryptoFunctions(scopeStack)
	builtin.InitializeRegexFunctions(scopeStack)
	builtin.InitializeSyncFunctions(scopeStack)
	
	exprs := p.ParseWithModules()

	for _, expr := range exprs {
		expr.Eval()
	}
}

// RunBytecodeMode –∑–∞–ø—É—Å–∫–∞–µ—Ç bytecode —Ä–µ–∂–∏–º (–∑–∞–≥–ª—É—à–∫–∞)
func RunBytecodeMode() {
	fmt.Println("Bytecode —Ä–µ–∂–∏–º –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ")
	fmt.Println("VM —Å–∏—Å—Ç–µ–º–∞ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞ –∏ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∞, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏")
}

// printUsage –≤—ã–≤–æ–¥–∏—Ç —Å–ø—Ä–∞–≤–∫—É –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é
func printUsage() {
	fmt.Println("foo_lang v2 - –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–µ–º—ã–π —è–∑—ã–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è")
	fmt.Println()
	fmt.Println("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:")
	fmt.Println("  go run main.go [—Ñ–∞–π–ª.foo] [—Ñ–ª–∞–≥–∏]")
	fmt.Println()
	fmt.Println("–§–ª–∞–≥–∏:")
	fmt.Println("  -b, --bytecode    –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å bytecode VM (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π)")
	fmt.Println("  -d, --disassemble –ü–æ–∫–∞–∑–∞—Ç—å –¥–∏–∑–∞—Å—Å–µ–º–±–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–π bytecode")
	fmt.Println("  -p, --profile     –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏")
	fmt.Println("  -c, --compare     –°—Ä–∞–≤–Ω–∏—Ç—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å tree-walking vs bytecode")
	fmt.Println("  -h, --help        –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É")
	fmt.Println()
	fmt.Println("–ü—Ä–∏–º–µ—Ä—ã:")
	fmt.Println("  go run main.go                                    # tree-walking –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä")
	fmt.Println("  go run main.go --bytecode                         # bytecode VM")
	fmt.Println("  go run main.go examples/test_bytecode_demo.foo -b # bytecode VM —Å —Ñ–∞–π–ª–æ–º")
	fmt.Println("  go run main.go --bytecode --profile --disassemble # –ø–æ–ª–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞")
	fmt.Println("  go run main.go --bytecode --compare               # —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏")
	fmt.Println()
	fmt.Println("–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:")
	fmt.Println("  ‚úÖ Generic —Ñ—É–Ω–∫—Ü–∏–∏ –∏ —Ç–∏–ø–∏–∑–∞—Ü–∏—è")
	fmt.Println("  ‚úÖ Interface —Å–∏—Å—Ç–µ–º–∞ –∏ Extension Methods") 
	fmt.Println("  ‚úÖ Async/await –∏ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ—Å—Ç—å")
	fmt.Println("  ‚úÖ HTTP –∫–ª–∏–µ–Ω—Ç/—Å–µ—Ä–≤–µ—Ä")
	fmt.Println("  ‚úÖ –§–∞–π–ª–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞")
	fmt.Println("  ‚úÖ Bytecode –∫–æ–º–ø–∏–ª—è—Ü–∏—è –∏ –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ")
}
	log.Printf("üöÄ Starting Foo Language LSP Server with AST parser...")
	
	stream := jsonrpc2.NewBufferedStream(&stdinStdoutCloser{Reader: os.Stdin, Writer: os.Stdout}, jsonrpc2.VSCodeObjectCodec{})
	handler := NewFooLanguageServer()
	<-jsonrpc2.NewConn(context.Background(), stream, handler).DisconnectNotify()
}

// stdinStdoutCloser –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç stdin –∏ stdout –¥–ª—è LSP
type stdinStdoutCloser struct {
	io.Reader
	io.Writer
}

func (c *stdinStdoutCloser) Close() error {
	return nil
}

// LSP —Å–µ—Ä–≤–µ—Ä —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π –Ω–∞—Å—Ç–æ—è—â–µ–≥–æ –ø–∞—Ä—Å–µ—Ä–∞
type FooLanguageServer struct {
	workspace *LSPWorkspace
}

func NewFooLanguageServer() *FooLanguageServer {
	return &FooLanguageServer{
		workspace: NewLSPWorkspace(),
	}
}

func (s *FooLanguageServer) Handle(ctx context.Context, conn *jsonrpc2.Conn, req *jsonrpc2.Request) {
	switch req.Method {
	case "initialize":
		s.handleInitialize(ctx, conn, req)
	case "initialized":
		// –≥–æ—Ç–æ–≤–æ
	case "textDocument/didOpen":
		s.handleDidOpen(ctx, conn, req)
	case "textDocument/didChange":
		s.handleDidChange(ctx, conn, req)
	case "textDocument/completion":
		s.handleCompletion(ctx, conn, req)
	case "textDocument/hover":
		s.handleHover(ctx, conn, req)
	case "shutdown":
		conn.Reply(ctx, req.ID, nil)
	case "exit":
		os.Exit(0)
	default:
		conn.ReplyWithError(ctx, req.ID, &jsonrpc2.Error{Code: jsonrpc2.CodeMethodNotFound, Message: "method not supported"})
	}
}

func (s *FooLanguageServer) handleInitialize(ctx context.Context, conn *jsonrpc2.Conn, req *jsonrpc2.Request) {
	response := map[string]interface{}{
		"capabilities": map[string]interface{}{
			"textDocumentSync": map[string]interface{}{
				"openClose": true,
				"change":    2,
			},
			"completionProvider": map[string]interface{}{
				"triggerCharacters": []string{".", "@"},
			},
			"hoverProvider": true,
		},
	}
	conn.Reply(ctx, req.ID, response)
}

func (s *FooLanguageServer) handleDidOpen(ctx context.Context, conn *jsonrpc2.Conn, req *jsonrpc2.Request) {
	var params map[string]interface{}
	json.Unmarshal(*req.Params, &params)
	
	textDoc := params["textDocument"].(map[string]interface{})
	uri := textDoc["uri"].(string)
	text := textDoc["text"].(string)
	
	s.workspace.AddDocument(uri, text)
}

func (s *FooLanguageServer) handleDidChange(ctx context.Context, conn *jsonrpc2.Conn, req *jsonrpc2.Request) {
	var params map[string]interface{}
	json.Unmarshal(*req.Params, &params)
	
	textDoc := params["textDocument"].(map[string]interface{})
	uri := textDoc["uri"].(string)
	
	changes := params["contentChanges"].([]interface{})
	if len(changes) > 0 {
		change := changes[0].(map[string]interface{})
		text := change["text"].(string)
		s.workspace.UpdateDocument(uri, text)
	}
}

func (s *FooLanguageServer) handleCompletion(ctx context.Context, conn *jsonrpc2.Conn, req *jsonrpc2.Request) {
	var params map[string]interface{}
	json.Unmarshal(*req.Params, &params)
	
	textDoc := params["textDocument"].(map[string]interface{})
	uri := textDoc["uri"].(string)
	
	completions := s.workspace.GetCompletions(uri)
	conn.Reply(ctx, req.ID, map[string]interface{}{"items": completions})
}

func (s *FooLanguageServer) handleHover(ctx context.Context, conn *jsonrpc2.Conn, req *jsonrpc2.Request) {
	var params map[string]interface{}
	json.Unmarshal(*req.Params, &params)
	
	textDoc := params["textDocument"].(map[string]interface{})
	uri := textDoc["uri"].(string)
	
	hover := s.workspace.GetHover(uri)
	conn.Reply(ctx, req.ID, hover)
}

// LSPWorkspace —Å AST –ø–∞—Ä—Å–µ—Ä–æ–º
type LSPWorkspace struct {
	documents map[string]*LSPDocument
	symbols   map[string][]*LSPSymbol
	parsers   map[string]*parser.Parser
	scopes    map[string]*scope.Scope
}

type LSPDocument struct {
	URI     string
	Content string
	Lines   []string
}

type LSPSymbol struct {
	Name          string
	Kind          int // LSP SymbolKind  
	Detail        string
	Type          string
	Signature     string
	Documentation string
}

func NewLSPWorkspace() *LSPWorkspace {
	return &LSPWorkspace{
		documents: make(map[string]*LSPDocument),
		symbols:   make(map[string][]*LSPSymbol),
		parsers:   make(map[string]*parser.Parser),
		scopes:    make(map[string]*scope.Scope),
	}
}

func (w *LSPWorkspace) AddDocument(uri, content string) {
	doc := &LSPDocument{
		URI:     uri,
		Content: content,
		Lines:   strings.Split(content, "\n"),
	}
	
	w.documents[uri] = doc
	
	// –°–æ–∑–¥–∞–µ–º AST –ø–∞—Ä—Å–µ—Ä
	l := lexer.New(content)
	p := parser.New(l)
	w.parsers[uri] = p
	w.scopes[uri] = scope.NewScope()
	
	w.analyzeWithAST(doc)
}

func (w *LSPWorkspace) UpdateDocument(uri, content string) {
	if doc, exists := w.documents[uri]; exists {
		doc.Content = content
		doc.Lines = strings.Split(content, "\n")
		
		// –ü–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º –ø–∞—Ä—Å–µ—Ä
		l := lexer.New(content)
		p := parser.New(l)
		w.parsers[uri] = p
		
		w.analyzeWithAST(doc)
	}
}

func (w *LSPWorkspace) analyzeWithAST(doc *LSPDocument) {
	log.Printf("üîç Analyzing with AST parser: %s", doc.URI)
	
	parser := w.parsers[doc.URI]
	if parser == nil {
		return
	}
	
	// –ü–∞—Ä—Å–∏–º –≤ AST
	program := parser.ParseProgram()
	if program == nil {
		return
	}
	
	symbols := w.extractSymbolsFromAST(program)
	w.symbols[doc.URI] = symbols
	
	log.Printf("‚úÖ Found %d symbols with AST: %s", len(symbols), doc.URI)
}

func (w *LSPWorkspace) extractSymbolsFromAST(program *ast.Program) []*LSPSymbol {
	symbols := []*LSPSymbol{}
	
	for _, expr := range program.Expressions {
		switch node := expr.(type) {
		case *ast.LetExpression:
			symbol := &LSPSymbol{
				Name:          node.Name.Value,
				Kind:          6, // Variable
				Detail:        "variable",
				Type:          w.inferTypeFromAST(node.Value),
				Documentation: fmt.Sprintf("Variable %s", node.Name.Value),
			}
			symbols = append(symbols, symbol)
			
		case *ast.FuncExpression:
			params := []string{}
			for _, param := range node.Params {
				params = append(params, param.Value)
			}
			
			symbol := &LSPSymbol{
				Name:          node.Name.Value,
				Kind:          3, // Function
				Detail:        "function",
				Type:          "function",
				Signature:     fmt.Sprintf("fn %s(%s)", node.Name.Value, strings.Join(params, ", ")),
				Documentation: fmt.Sprintf("Function %s with %d parameters", node.Name.Value, len(params)),
			}
			symbols = append(symbols, symbol)
		}
	}
	
	return symbols
}

func (w *LSPWorkspace) inferTypeFromAST(expr ast.Expr) string {
	if expr == nil {
		return "unknown"
	}
	
	switch expr.(type) {
	case *ast.IntLiteral:
		return "int"
	case *ast.StringLiteral:
		return "string"
	case *ast.BoolLiteral:
		return "bool"
	case *ast.ArrayLiteral:
		return "array"
	default:
		return "unknown"
	}
}

func (w *LSPWorkspace) GetCompletions(uri string) []map[string]interface{} {
	completions := []map[string]interface{}{}
	
	// –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
	keywords := []string{"let", "const", "fn", "struct", "interface", "if", "else", "for", "return", "import", "export", "async", "await"}
	for _, keyword := range keywords {
		completions = append(completions, map[string]interface{}{
			"label": keyword,
			"kind":  14, // Keyword
		})
	}
	
	// –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
	builtins := []string{"print", "println", "sin", "cos", "sqrt", "abs", "readFile", "writeFile", "httpGet", "httpPost"}
	for _, builtin := range builtins {
		completions = append(completions, map[string]interface{}{
			"label": builtin,
			"kind":  3, // Function
		})
	}
	
	// –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ —Å–∏–º–≤–æ–ª—ã –∏–∑ AST
	if symbols, exists := w.symbols[uri]; exists {
		for _, symbol := range symbols {
			completions = append(completions, map[string]interface{}{
				"label":  symbol.Name,
				"kind":   symbol.Kind,
				"detail": symbol.Detail,
			})
		}
	}
	
	return completions
}

func (w *LSPWorkspace) GetHover(uri string) map[string]interface{} {
	if symbols, exists := w.symbols[uri]; exists {
		for _, symbol := range symbols {
			return map[string]interface{}{
				"contents": map[string]interface{}{
					"kind":  "markdown",
					"value": fmt.Sprintf("**%s** `%s`\n\n%s", symbol.Name, symbol.Type, symbol.Documentation),
				},
			}
		}
	}
	
	return nil
}
