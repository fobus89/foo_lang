// std/time.foo - –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∞—Ç–æ–π –∏ –≤—Ä–µ–º–µ–Ω–µ–º
// ‚è∞ –ú–æ–¥—É–ª—å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –º–µ—Ç–∫–∞–º–∏, –¥–∞—Ç–∞–º–∏, —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∏ –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–æ–π –≤—Ä–µ–º–µ–Ω–∏

// üïê –°–æ–∑–¥–∞–Ω–∏–µ –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏
export fn now() {
    return __builtin_now()
}

export fn fromUnix(timestamp) {
    return __builtin_timeFromUnix(timestamp)
}

export fn fromString(timeString, format = "2006-01-02 15:04:05") {
    return __builtin_timeFromString(timeString)
}

export fn fromISO(isoString) {
    // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç ISO 8601 —Ñ–æ—Ä–º–∞—Ç: 2023-01-15T14:30:00Z
    return fromString(isoString, "2006-01-02T15:04:05Z")
}

// üìÖ –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≤—Ä–µ–º–µ–Ω–∏
export fn year(time) {
    return __builtin_timeYear(time)
}

export fn month(time) {
    return __builtin_timeMonth(time)
}

export fn day(time) {
    return __builtin_timeDay(time)
}

export fn hour(time) {
    return __builtin_timeHour(time)
}

export fn minute(time) {
    return __builtin_timeMinute(time)
}

export fn second(time) {
    return __builtin_timeSecond(time)
}

export fn weekday(time) {
    return __builtin_timeWeekday(time)
}

export fn yearDay(time) {
    let start = fromString(year(time).toString() + "-01-01 00:00:00")
    let diff = diffDays(time, start)
    return diff.unwrapOr(0) + 1
}

// üé® –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
export fn format(time, layout = "2006-01-02 15:04:05") {
    return __builtin_timeFormat(time, layout)
}

export fn formatISO(time) {
    return format(time, "2006-01-02T15:04:05Z")
}

export fn formatRFC3339(time) {
    return format(time, "2006-01-02T15:04:05Z07:00")
}

export fn formatUnix(time) {
    return toUnix(time)
}

export fn formatHuman(time) {
    let currentTime = now()
    let diffSeconds = diffSeconds(currentTime, time).unwrapOr(0)
    
    if diffSeconds < 0 {
        diffSeconds = -diffSeconds
        
        if diffSeconds < 60 {
            return "—á–µ—Ä–µ–∑ " + diffSeconds.toString() + " —Å–µ–∫"
        } else if diffSeconds < 3600 {
            let minutes = Math.floor(diffSeconds / 60)
            return "—á–µ—Ä–µ–∑ " + minutes.toString() + " –º–∏–Ω"
        } else if diffSeconds < 86400 {
            let hours = Math.floor(diffSeconds / 3600)
            return "—á–µ—Ä–µ–∑ " + hours.toString() + " —á"
        }
    } else {
        if diffSeconds < 60 {
            return diffSeconds.toString() + " —Å–µ–∫ –Ω–∞–∑–∞–¥"
        } else if diffSeconds < 3600 {
            let minutes = Math.floor(diffSeconds / 60)
            return minutes.toString() + " –º–∏–Ω –Ω–∞–∑–∞–¥"
        } else if diffSeconds < 86400 {
            let hours = Math.floor(diffSeconds / 3600)
            return hours.toString() + " —á –Ω–∞–∑–∞–¥"
        } else if diffSeconds < 86400 * 7 {
            let days = Math.floor(diffSeconds / 86400)
            return days.toString() + " –¥–Ω –Ω–∞–∑–∞–¥"
        }
    }
    
    return format(time, "02.01.2006")
}

// ‚ö° Unix timestamps
export fn toUnix(time) {
    return __builtin_timeUnix(time)
}

export fn toUnixMilli(time) {
    return toUnix(time) * 1000
}

export fn toUnixMicro(time) {
    return toUnix(time) * 1000000
}

// ‚ûï –ê—Ä–∏—Ñ–º–µ—Ç–∏–∫–∞ –≤—Ä–µ–º–µ–Ω–∏
export fn addSeconds(time, seconds) {
    return __builtin_timeAddSeconds(time, seconds)
}

export fn addMinutes(time, minutes) {
    return __builtin_timeAddMinutes(time, minutes)
}

export fn addHours(time, hours) {
    return __builtin_timeAddHours(time, hours)
}

export fn addDays(time, days) {
    return __builtin_timeAddDays(time, days)
}

export fn addMonths(time, months) {
    return __builtin_timeAddMonths(time, months)
}

export fn addYears(time, years) {
    return __builtin_timeAddYears(time, years)
}

export fn addDuration(time, duration) {
    // duration –≤ —Ñ–æ—Ä–º–∞—Ç–µ "1h30m45s", "2d12h", "15m", "30s"
    let totalSeconds = parseDuration(duration)
    if totalSeconds.isErr() {
        return totalSeconds
    }
    
    return addSeconds(time, totalSeconds.unwrap())
}

// ‚è≥ –†–∞–∑–Ω–æ—Å—Ç–∏ –∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
export fn diff(time1, time2) {
    return __builtin_timeDiff(time1, time2)
}

export fn diffSeconds(time1, time2) {
    return __builtin_timeDiffSeconds(time1, time2)
}

export fn diffMinutes(time1, time2) {
    return __builtin_timeDiffMinutes(time1, time2)
}

export fn diffHours(time1, time2) {
    return __builtin_timeDiffHours(time1, time2)
}

export fn diffDays(time1, time2) {
    return __builtin_timeDiffDays(time1, time2)
}

export fn diffWeeks(time1, time2) {
    let days = diffDays(time1, time2)
    if days.isOk() {
        return Ok(Math.floor(days.unwrap() / 7))
    }
    return days
}

export fn diffMonths(time1, time2) {
    let year1 = year(time1)
    let month1 = month(time1)
    let year2 = year(time2)
    let month2 = month(time2)
    
    return (year1 - year2) * 12 + (month1 - month2)
}

export fn diffYears(time1, time2) {
    return year(time1) - year(time2)
}

// üîç –°—Ä–∞–≤–Ω–µ–Ω–∏—è
export fn before(time1, time2) {
    return __builtin_timeBefore(time1, time2)
}

export fn after(time1, time2) {
    return __builtin_timeAfter(time1, time2)
}

export fn equal(time1, time2) {
    return __builtin_timeEqual(time1, time2)
}

export fn isSameDay(time1, time2) {
    return year(time1) == year(time2) && 
           month(time1) == month(time2) && 
           day(time1) == day(time2)
}

export fn isSameWeek(time1, time2) {
    let diff = diffDays(time1, time2)
    if diff.isOk() {
        return Math.abs(diff.unwrap()) < 7
    }
    return false
}

export fn isSameMonth(time1, time2) {
    return year(time1) == year(time2) && month(time1) == month(time2)
}

export fn isSameYear(time1, time2) {
    return year(time1) == year(time2)
}

// üìä –£—Ç–∏–ª–∏—Ç—ã –∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è
export fn isLeapYear(yearValue) {
    return (yearValue % 4 == 0 && yearValue % 100 != 0) || (yearValue % 400 == 0)
}

export fn daysInMonth(yearValue, monthValue) {
    let daysPerMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    if monthValue == 2 && isLeapYear(yearValue) {
        return 29
    }
    
    if monthValue >= 1 && monthValue <= 12 {
        return daysPerMonth[monthValue - 1]
    }
    
    return 0
}

export fn daysInYear(yearValue) {
    return isLeapYear(yearValue) ? 366 : 365
}

export fn startOfDay(time) {
    let yearVal = year(time)
    let monthVal = month(time)
    let dayVal = day(time)
    
    return fromString(yearVal.toString() + "-" + 
                     monthVal.toString().padStart(2, "0") + "-" + 
                     dayVal.toString().padStart(2, "0") + " 00:00:00")
}

export fn endOfDay(time) {
    let yearVal = year(time)
    let monthVal = month(time)
    let dayVal = day(time)
    
    return fromString(yearVal.toString() + "-" + 
                     monthVal.toString().padStart(2, "0") + "-" + 
                     dayVal.toString().padStart(2, "0") + " 23:59:59")
}

export fn startOfWeek(time, firstDayIsMonday = true) {
    let wd = weekday(time) // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
    let daysToSubtract = firstDayIsMonday ? (wd == 0 ? 6 : wd - 1) : wd
    
    let startDay = addDays(time, -daysToSubtract)
    return startOfDay(startDay)
}

export fn endOfWeek(time, firstDayIsMonday = true) {
    let startWeek = startOfWeek(time, firstDayIsMonday)
    let endWeek = addDays(startWeek, 6)
    return endOfDay(endWeek)
}

export fn startOfMonth(time) {
    let yearVal = year(time)
    let monthVal = month(time)
    
    return fromString(yearVal.toString() + "-" + 
                     monthVal.toString().padStart(2, "0") + "-01 00:00:00")
}

export fn endOfMonth(time) {
    let yearVal = year(time)
    let monthVal = month(time)
    let lastDay = daysInMonth(yearVal, monthVal)
    
    return fromString(yearVal.toString() + "-" + 
                     monthVal.toString().padStart(2, "0") + "-" + 
                     lastDay.toString().padStart(2, "0") + " 23:59:59")
}

export fn startOfYear(time) {
    let yearVal = year(time)
    return fromString(yearVal.toString() + "-01-01 00:00:00")
}

export fn endOfYear(time) {
    let yearVal = year(time)
    return fromString(yearVal.toString() + "-12-31 23:59:59")
}

// üîÑ –ü–∞—Ä—Å–∏–Ω–≥ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è
export fn parseDuration(durationString) {
    let totalSeconds = 0
    let remaining = durationString
    
    // –ü–∞—Ä—Å–∏–º –¥–Ω–∏ (d)
    if remaining.indexOf("d") >= 0 {
        let dIndex = remaining.indexOf("d")
        let daysStr = remaining.substring(0, dIndex)
        if daysStr != "" {
            let days = parseInt(daysStr)
            if days != null {
                totalSeconds += days * 86400
            }
        }
        remaining = remaining.substring(dIndex + 1)
    }
    
    // –ü–∞—Ä—Å–∏–º —á–∞—Å—ã (h)
    if remaining.indexOf("h") >= 0 {
        let hIndex = remaining.indexOf("h")
        let hoursStr = remaining.substring(0, hIndex)
        if hoursStr != "" {
            let hours = parseInt(hoursStr)
            if hours != null {
                totalSeconds += hours * 3600
            }
        }
        remaining = remaining.substring(hIndex + 1)
    }
    
    // –ü–∞—Ä—Å–∏–º –º–∏–Ω—É—Ç—ã (m)
    if remaining.indexOf("m") >= 0 {
        let mIndex = remaining.indexOf("m")
        let minutesStr = remaining.substring(0, mIndex)
        if minutesStr != "" {
            let minutes = parseInt(minutesStr)
            if minutes != null {
                totalSeconds += minutes * 60
            }
        }
        remaining = remaining.substring(mIndex + 1)
    }
    
    // –ü–∞—Ä—Å–∏–º —Å–µ–∫—É–Ω–¥—ã (s)
    if remaining.indexOf("s") >= 0 {
        let sIndex = remaining.indexOf("s")
        let secondsStr = remaining.substring(0, sIndex)
        if secondsStr != "" {
            let seconds = parseInt(secondsStr)
            if seconds != null {
                totalSeconds += seconds
            }
        }
    }
    
    return Ok(totalSeconds)
}

export fn isValidTimeString(timeString, format = "2006-01-02 15:04:05") {
    let parsed = fromString(timeString, format)
    return parsed.isOk()
}

export fn isValidISO(isoString) {
    return isValidTimeString(isoString, "2006-01-02T15:04:05Z")
}

export fn isWeekend(time) {
    let wd = weekday(time)
    return wd == 0 || wd == 6 // Sunday or Saturday
}

export fn isWorkday(time) {
    return !isWeekend(time)
}

// üåç –í—Ä–µ–º–µ–Ω–Ω—ã–µ –∑–æ–Ω—ã (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞)
export fn toUTC(time) {
    // –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∑–¥–µ—Å—å –Ω—É–∂–Ω–∞ –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∑–æ–Ω
    return time // –ó–∞–≥–ª—É—à–∫–∞ - —Å—á–∏—Ç–∞–µ–º —á—Ç–æ –≤—Ä–µ–º—è —É–∂–µ –≤ UTC
}

export fn fromUTC(time, timezone = "local") {
    // –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∏–∑ UTC –≤ –ª–æ–∫–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è
    return time
}

export fn getTimezone() {
    // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—É—â—É—é –≤—Ä–µ–º–µ–Ω–Ω—É—é –∑–æ–Ω—É
    return "UTC" // –ó–∞–≥–ª—É—à–∫–∞
}

// üìà –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã
export fn range(startTime, endTime, step = "1d") {
    let times = []
    let current = startTime
    let stepSeconds = parseDuration(step)
    
    if stepSeconds.isErr() {
        return stepSeconds
    }
    
    let stepSec = stepSeconds.unwrap()
    
    while before(current, endTime) || equal(current, endTime) {
        times.push(current)
        current = addSeconds(current, stepSec)
        
        // –ó–∞—â–∏—Ç–∞ –æ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ —Ü–∏–∫–ª–∞
        if times.length() > 10000 {
            return Err("Time range too large (>10000 entries)")
        }
    }
    
    return Ok(times)
}

export fn eachDay(startTime, endTime) {
    return range(startTime, endTime, "1d")
}

export fn eachHour(startTime, endTime) {
    return range(startTime, endTime, "1h")
}

export fn eachWeek(startTime, endTime) {
    return range(startTime, endTime, "7d")
}

export fn eachMonth(startTime, endTime) {
    let times = []
    let current = startTime
    
    while before(current, endTime) || equal(current, endTime) {
        times.push(current)
        current = addMonths(current, 1)
        
        // –ó–∞—â–∏—Ç–∞ –æ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ —Ü–∏–∫–ª–∞
        if times.length() > 1200 { // max 100 –ª–µ—Ç
            return Err("Time range too large")
        }
    }
    
    return Ok(times)
}

// üéØ –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã
export let FORMATS = {
    "ISO": "2006-01-02T15:04:05Z",
    "RFC3339": "2006-01-02T15:04:05Z07:00",
    "RFC822": "02 Jan 06 15:04 MST",
    "DATETIME": "2006-01-02 15:04:05",
    "DATE": "2006-01-02",
    "TIME": "15:04:05",
    "TIMESTAMP": "20060102_150405",
    "HUMAN": "January 2, 2006 3:04 PM",
    "SHORT": "02.01.06",
    "LONG": "Monday, January 2, 2006"
}

// üé≤ –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
export fn sleep(milliseconds) {
    return __builtin_sleep(milliseconds)
}

export fn sleepSeconds(seconds) {
    return sleep(seconds * 1000)
}

export fn sleepMinutes(minutes) {
    return sleep(minutes * 60 * 1000)
}

export fn benchmark(func) {
    let start = now()
    let result = func()
    let end = now()
    let duration = diffSeconds(end, start)
    
    return {
        "result": result,
        "duration": duration.unwrapOr(0),
        "start": start,
        "end": end
    }
}

export fn timeout(func, timeoutMs) {
    // –ü—Ä–æ—Å—Ç–∞—è –∏–º–∏—Ç–∞—Ü–∏—è timeout (–≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–Ω—ã goroutines)
    let start = now()
    let result = func()
    let end = now()
    let elapsed = diffSeconds(end, start).unwrapOr(0) * 1000
    
    if elapsed > timeoutMs {
        return Err("Function execution timed out after " + timeoutMs.toString() + "ms")
    }
    
    return Ok(result)
}

// üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞
export fn getBusinessDays(startTime, endTime) {
    let days = eachDay(startTime, endTime)
    if days.isErr() {
        return days
    }
    
    let businessDays = []
    let daysList = days.unwrap()
    
    for let i = 0; i < daysList.length(); i++ {
        let day = daysList[i]
        if isWorkday(day) {
            businessDays.push(day)
        }
    }
    
    return Ok(businessDays)
}

export fn age(birthDate) {
    let currentTime = now()
    let years = diffYears(currentTime, birthDate)
    let months = diffMonths(currentTime, birthDate) % 12
    let daysDiff = diffDays(currentTime, addYears(birthDate, years))
    
    return {
        "years": years,
        "months": months,
        "days": daysDiff.unwrapOr(0),
        "totalDays": diffDays(currentTime, birthDate).unwrapOr(0)
    }
}

export fn nextBirthday(birthDate) {
    let currentTime = now()
    let currentYear = year(currentTime)
    let birthMonth = month(birthDate)
    let birthDay = day(birthDate)
    
    let thisYearBirthday = fromString(currentYear.toString() + "-" + 
                                    birthMonth.toString().padStart(2, "0") + "-" + 
                                    birthDay.toString().padStart(2, "0") + " 00:00:00")
    
    if after(thisYearBirthday, currentTime) {
        return thisYearBirthday
    } else {
        return fromString((currentYear + 1).toString() + "-" + 
                         birthMonth.toString().padStart(2, "0") + "-" + 
                         birthDay.toString().padStart(2, "0") + " 00:00:00")
    }
}

// üéØ –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
export let SECONDS_IN_MINUTE = 60
export let SECONDS_IN_HOUR = 3600
export let SECONDS_IN_DAY = 86400
export let SECONDS_IN_WEEK = 604800
export let SECONDS_IN_YEAR = 31536000

export let MILLISECONDS_IN_SECOND = 1000
export let MILLISECONDS_IN_MINUTE = 60000
export let MILLISECONDS_IN_HOUR = 3600000
export let MILLISECONDS_IN_DAY = 86400000

export let DAYS_IN_WEEK = 7
export let MONTHS_IN_YEAR = 12

export let WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
export let WEEKDAYS_SHORT = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
export let MONTHS = ["January", "February", "March", "April", "May", "June", 
                    "July", "August", "September", "October", "November", "December"]
export let MONTHS_SHORT = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]