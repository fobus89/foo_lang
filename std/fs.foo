// std/fs.foo - –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π
// üóÇÔ∏è –ú–æ–¥—É–ª—å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏ –∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è–º–∏

// üìñ –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤
export fn readFile(path) {
    return __builtin_readFile(path)
}

export fn readLines(path) {
    let content = readFile(path)
    if content.isErr() {
        return content // –ü–µ—Ä–µ–¥–∞–µ–º –æ—à–∏–±–∫—É –¥–∞–ª—å—à–µ
    }
    
    let text = content.unwrap()
    let lines = text.split("\\n")
    return Ok(lines)
}

// ‚úçÔ∏è –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∑–∞–ø–∏—Å–∏ —Ñ–∞–π–ª–æ–≤
export fn writeFile(path, content) {
    return __builtin_writeFile(path, content)
}

export fn appendFile(path, content) {
    let existing = readFile(path)
    let newContent = content
    
    if existing.isOk() {
        newContent = existing.unwrap() + content
    }
    
    return writeFile(path, newContent)
}

export fn writeLines(path, lines) {
    let content = lines.join("\\n")
    return writeFile(path, content)
}

// üìÅ –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è–º–∏
export fn mkdir(path) {
    return __builtin_mkdir(path)
}

export fn mkdirAll(path) {
    // –°–æ–∑–¥–∞–µ—Ç –≤—Å–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
    let parts = path.split("/")
    let currentPath = ""
    
    for let i = 0; i < parts.length(); i++ {
        if parts[i] != "" {
            currentPath = currentPath + "/" + parts[i]
            let result = mkdir(currentPath)
            if result.isErr() && !exists(currentPath) {
                return result // –ü–µ—Ä–µ–¥–∞–µ–º –æ—à–∏–±–∫—É, –µ—Å–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å
            }
        }
    }
    
    return Ok("directories created")
}

export fn listDir(path) {
    return __builtin_listDir(path)
}

export fn listDirDetailed(path) {
    let files = listDir(path)
    if files.isErr() {
        return files
    }
    
    let detailed = []
    let fileList = files.unwrap()
    
    for let i = 0; i < fileList.length(); i++ {
        let filename = fileList[i]
        let fullPath = path + "/" + filename
        let info = {
            "name": filename,
            "path": fullPath,
            "isFile": isFile(fullPath),
            "isDir": isDir(fullPath),
            "size": getFileSize(fullPath).unwrapOr(0)
        }
        detailed.push(info)
    }
    
    return Ok(detailed)
}

// üîç –§—É–Ω–∫—Ü–∏–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è
export fn exists(path) {
    return __builtin_exists(path)
}

export fn isFile(path) {
    return __builtin_isFile(path)
}

export fn isDir(path) {
    return __builtin_isDir(path)
}

// üìä –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ñ–∞–π–ª–∞—Ö
export fn getFileSize(path) {
    return __builtin_getFileSize(path)
}

export fn getFileInfo(path) {
    if !exists(path) {
        return Err("File does not exist: " + path)
    }
    
    let info = {
        "path": path,
        "exists": true,
        "isFile": isFile(path),
        "isDir": isDir(path),
        "size": getFileSize(path).unwrapOr(0)
    }
    
    return Ok(info)
}

// üìã –§—É–Ω–∫—Ü–∏–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è
export fn copyFile(src, dest) {
    return __builtin_copyFile(src, dest)
}

export fn copyDir(src, dest) {
    if !isDir(src) {
        return Err("Source is not a directory: " + src)
    }
    
    // –°–æ–∑–¥–∞–µ–º —Ü–µ–ª–µ–≤—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
    let mkResult = mkdir(dest)
    if mkResult.isErr() && !exists(dest) {
        return mkResult
    }
    
    // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤
    let files = listDir(src)
    if files.isErr() {
        return files
    }
    
    let fileList = files.unwrap()
    for let i = 0; i < fileList.length(); i++ {
        let filename = fileList[i]
        let srcPath = src + "/" + filename
        let destPath = dest + "/" + filename
        
        if isDir(srcPath) {
            // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –∫–æ–ø–∏—Ä—É–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
            let result = copyDir(srcPath, destPath)
            if result.isErr() {
                return result
            }
        } else {
            // –ö–æ–ø–∏—Ä—É–µ–º —Ñ–∞–π–ª
            let result = copyFile(srcPath, destPath)
            if result.isErr() {
                return result
            }
        }
    }
    
    return Ok("Directory copied successfully")
}

// üóëÔ∏è –§—É–Ω–∫—Ü–∏–∏ —É–¥–∞–ª–µ–Ω–∏—è
export fn removeFile(path) {
    return __builtin_removeFile(path)
}

export fn removeDir(path, recursive = false) {
    if !recursive {
        // –ü—Ä–æ—Å—Ç–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –ø—É—Å—Ç–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
        return __builtin_removeFile(path)
    }
    
    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ
    if !isDir(path) {
        return removeFile(path)
    }
    
    let files = listDir(path)
    if files.isErr() {
        return files
    }
    
    let fileList = files.unwrap()
    for let i = 0; i < fileList.length(); i++ {
        let filename = fileList[i]
        let fullPath = path + "/" + filename
        
        let result = removeDir(fullPath, true)
        if result.isErr() {
            return result
        }
    }
    
    // –£–¥–∞–ª—è–µ–º —Å–∞–º—É –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø–æ—Å–ª–µ –æ—á–∏—Å—Ç–∫–∏
    return removeFile(path)
}

// üîç –£—Ç–∏–ª–∏—Ç–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
export fn findFiles(dir, pattern) {
    let found = []
    
    let files = listDir(dir)
    if files.isErr() {
        return files
    }
    
    let fileList = files.unwrap()
    for let i = 0; i < fileList.length(); i++ {
        let filename = fileList[i]
        let fullPath = dir + "/" + filename
        
        // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ç—Ç–µ—Ä–Ω–∞ (—Å–æ–¥–µ—Ä–∂–∏—Ç –ø–æ–¥—Å—Ç—Ä–æ–∫—É)
        if filename.indexOf(pattern) >= 0 {
            found.push(fullPath)
        }
        
        // –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫ –≤ –ø–æ–¥–ø–∞–ø–∫–∞—Ö
        if isDir(fullPath) {
            let subResults = findFiles(fullPath, pattern)
            if subResults.isOk() {
                let subFiles = subResults.unwrap()
                for let j = 0; j < subFiles.length(); j++ {
                    found.push(subFiles[j])
                }
            }
        }
    }
    
    return Ok(found)
}

export fn walkDir(dir, callback) {
    let files = listDir(dir)
    if files.isErr() {
        return files
    }
    
    let fileList = files.unwrap()
    for let i = 0; i < fileList.length(); i++ {
        let filename = fileList[i]
        let fullPath = dir + "/" + filename
        
        // –í—ã–∑—ã–≤–∞–µ–º callback –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ñ–∞–π–ª–∞/–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
        callback(fullPath, isDir(fullPath))
        
        // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ö–æ–¥–∏–º –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
        if isDir(fullPath) {
            walkDir(fullPath, callback)
        }
    }
    
    return Ok("Walk completed")
}

// üìù –§—É–Ω–∫—Ü–∏–∏ —Ä–∞–±–æ—Ç—ã —Å –ø—É—Ç—è–º–∏
export fn basename(path) {
    let parts = path.split("/")
    return parts[parts.length() - 1]
}

export fn dirname(path) {
    let parts = path.split("/")
    if parts.length() <= 1 {
        return "."
    }
    
    // –£–±–∏—Ä–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç
    let dirParts = []
    for let i = 0; i < parts.length() - 1; i++ {
        dirParts.push(parts[i])
    }
    
    return dirParts.join("/")
}

export fn extname(path) {
    let filename = basename(path)
    let dotIndex = filename.lastIndexOf(".")
    
    if dotIndex >= 0 {
        return filename.substring(dotIndex)
    }
    
    return ""
}

export fn joinPath(parts...) {
    let result = ""
    
    for let i = 0; i < parts.length(); i++ {
        if i == 0 {
            result = parts[i]
        } else {
            if !result.endsWith("/") && !parts[i].startsWith("/") {
                result = result + "/"
            }
            result = result + parts[i]
        }
    }
    
    return result
}

// üîß –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
export fn getHomeDir() {
    return System.getEnv("HOME").unwrapOr("/home/user")
}

export fn getTempDir() {
    return System.getEnv("TMPDIR").unwrapOr("/tmp")
}

export fn getCurrentDir() {
    return System.getEnv("PWD").unwrapOr(".")
}

// üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
export fn getDirSize(path) {
    if !isDir(path) {
        return getFileSize(path)
    }
    
    let totalSize = 0
    let files = listDir(path)
    
    if files.isErr() {
        return files
    }
    
    let fileList = files.unwrap()
    for let i = 0; i < fileList.length(); i++ {
        let filename = fileList[i]
        let fullPath = path + "/" + filename
        
        if isDir(fullPath) {
            let subSize = getDirSize(fullPath)
            if subSize.isOk() {
                totalSize = totalSize + subSize.unwrap()
            }
        } else {
            let fileSize = getFileSize(fullPath)
            if fileSize.isOk() {
                totalSize = totalSize + fileSize.unwrap()
            }
        }
    }
    
    return Ok(totalSize)
}

export fn getDirStats(path) {
    if !isDir(path)) {
        return Err("Path is not a directory: " + path)
    }
    
    let stats = {
        "path": path,
        "totalFiles": 0,
        "totalDirs": 0,
        "totalSize": 0
    }
    
    let files = listDir(path)
    if files.isErr() {
        return files
    }
    
    let fileList = files.unwrap()
    for let i = 0; i < fileList.length(); i++ {
        let filename = fileList[i]
        let fullPath = path + "/" + filename
        
        if isDir(fullPath) {
            stats["totalDirs"] = stats["totalDirs"] + 1
            
            let subStats = getDirStats(fullPath)
            if subStats.isOk() {
                let subData = subStats.unwrap()
                stats["totalFiles"] = stats["totalFiles"] + subData["totalFiles"]
                stats["totalDirs"] = stats["totalDirs"] + subData["totalDirs"]
                stats["totalSize"] = stats["totalSize"] + subData["totalSize"]
            }
        } else {
            stats["totalFiles"] = stats["totalFiles"] + 1
            let fileSize = getFileSize(fullPath).unwrapOr(0)
            stats["totalSize"] = stats["totalSize"] + fileSize
        }
    }
    
    return Ok(stats)
}