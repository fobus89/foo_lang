// std/crypto.foo - –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
// üîê –ú–æ–¥—É–ª—å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º, –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å—é

// üî¢ –•–µ—à —Ñ—É–Ω–∫—Ü–∏–∏
export fn md5(data) {
    return __builtin_md5Hash(data)
}

export fn sha1(data) {
    return __builtin_sha1Hash(data)
}

export fn sha256(data) {
    return __builtin_sha256Hash(data)
}

export fn sha512(data) {
    return __builtin_sha512Hash(data)
}

// üîó HMAC –ø–æ–¥–ø–∏—Å–∏
export fn hmacSHA256(data, key) {
    return __builtin_hmacSHA256(data, key)
}

export fn hmacSHA1(data, key) {
    return __builtin_hmacSHA1(data, key)
}

export fn hmacMD5(data, key) {
    return __builtin_hmacMD5(data, key)
}

// üì¶ Base64 –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ
export fn base64Encode(data) {
    return __builtin_base64Encode(data)
}

export fn base64Decode(data) {
    return __builtin_base64Decode(data)
}

export fn base64URLEncode(data) {
    return __builtin_base64URLEncode(data)
}

export fn base64URLDecode(data) {
    return __builtin_base64URLDecode(data)
}

// üî§ Hex –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ
export fn hexEncode(data) {
    return __builtin_hexEncode(data)
}

export fn hexDecode(data) {
    return __builtin_hexDecode(data)
}

// üé≤ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
export fn randomBytes(length) {
    return __builtin_randomBytes(length)
}

export fn randomString(length) {
    return __builtin_randomString(length)
}

export fn randomInt(min, max) {
    return __builtin_randomInt(min, max)
}

export fn randomUUID() {
    return __builtin_randomUUID()
}

// üîë –†–∞–±–æ—Ç–∞ —Å –ø–∞—Ä–æ–ª—è–º–∏
export fn hashPassword(password, salt = null) {
    if salt == null {
        salt = randomString(32)
    }
    
    let combined = password + salt
    let hashed = sha256(combined)
    
    return Ok({
        "hash": hashed,
        "salt": salt,
        "algorithm": "SHA256"
    })
}

export fn verifyPassword(password, storedHash, salt) {
    let combined = password + salt
    let computedHash = sha256(combined)
    
    return constantTimeCompare(computedHash, storedHash)
}

// üõ°Ô∏è –ë–µ–∑–æ–ø–∞—Å–Ω—ã–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
export fn constantTimeCompare(a, b) {
    return __builtin_constantTimeCompare(a, b)
}

// üîê –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Ö–µ—à —Ñ—É–Ω–∫—Ü–∏–∏
export fn pbkdf2(password, salt, iterations, keyLength, hashFunc = "sha256") {
    // –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è PBKDF2 (–∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è demo)
    let result = password
    
    for let i = 0; i < iterations; i++ {
        switch hashFunc {
            case "sha256":
                result = sha256(result + salt)
            case "sha1":
                result = sha1(result + salt)
            case "md5":
                result = md5(result + salt)
            default:
                return Err("Unsupported hash function: " + hashFunc)
        }
    }
    
    // –û–±—Ä–µ–∑–∞–µ–º –¥–æ –Ω—É–∂–Ω–æ–π –¥–ª–∏–Ω—ã
    if keyLength > 0 && result.length() > keyLength * 2 {
        result = result.substring(0, keyLength * 2)
    }
    
    return Ok(result)
}

export fn bcrypt(password, cost = 12) {
    // –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è bcrypt - –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–Ω–∞ —Å–µ—Ä—å–µ–∑–Ω–∞—è –∫—Ä–∏–ø—Ç–æ–±–∏–±–ª–∏–æ—Ç–µ–∫–∞
    let salt = randomString(22)
    let rounds = cost
    
    let hashed = password
    for let i = 0; i < rounds; i++ {
        hashed = sha256(hashed + salt + i.toString())
    }
    
    return Ok({
        "hash": hashed,
        "salt": salt,
        "cost": cost,
        "algorithm": "bcrypt-like"
    })
}

// üîÄ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π –∏ —Ç–æ–∫–µ–Ω–æ–≤
export fn generateSecretKey(length = 32) {
    let chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
    let result = ""
    
    for let i = 0; i < length; i++ {
        let index = randomInt(0, chars.length() - 1)
        result = result + chars.charAt(index)
    }
    
    return result
}

export fn generateJWT(payload, secret, algorithm = "HS256") {
    // –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è JWT (–¥–ª—è –¥–µ–º–æ)
    let header = {
        "alg": algorithm,
        "typ": "JWT"
    }
    
    let encodedHeader = base64URLEncode(JSON.stringify(header))
    let encodedPayload = base64URLEncode(JSON.stringify(payload))
    
    let message = encodedHeader + "." + encodedPayload
    let signature = ""
    
    switch algorithm {
        case "HS256":
            signature = hmacSHA256(message, secret)
        case "HS1":
            signature = hmacSHA1(message, secret)
        default:
            return Err("Unsupported JWT algorithm: " + algorithm)
    }
    
    let encodedSignature = base64URLEncode(signature)
    
    return Ok(message + "." + encodedSignature)
}

export fn verifyJWT(token, secret, algorithm = "HS256") {
    let parts = token.split(".")
    if parts.length() != 3 {
        return Err("Invalid JWT format")
    }
    
    let header = parts[0]
    let payload = parts[1]
    let signature = parts[2]
    
    let message = header + "." + payload
    let expectedSignature = ""
    
    switch algorithm {
        case "HS256":
            expectedSignature = hmacSHA256(message, secret)
        case "HS1":
            expectedSignature = hmacSHA1(message, secret)
        default:
            return Err("Unsupported JWT algorithm: " + algorithm)
    }
    
    let encodedExpectedSignature = base64URLEncode(expectedSignature)
    
    if constantTimeCompare(signature, encodedExpectedSignature) {
        let decodedPayload = base64URLDecode(payload)
        let parsedPayload = JSON.parse(decodedPayload)
        if parsedPayload.isOk() {
            return Ok(parsedPayload.unwrap())
        } else {
            return Err("Invalid JWT payload")
        }
    } else {
        return Err("JWT signature verification failed")
    }
}

// üéØ –ö—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–∏–µ —É—Ç–∏–ª–∏—Ç—ã
export fn secureRandom(min, max) {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–∏–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä
    let range = max - min + 1
    let randomValue = randomBytes(4) // 4 –±–∞–π—Ç–∞ –¥–ª—è 32-–±–∏—Ç–Ω–æ–≥–æ —á–∏—Å–ª–∞
    
    // –ü—Ä–æ—Å—Ç–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –±–∞–π—Ç–æ–≤ –≤ —á–∏—Å–ª–æ
    let bytes = hexDecode(randomValue)
    let num = 0
    for let i = 0; i < bytes.length(); i++ {
        num = num * 256 + bytes.charAt(i).charCodeAt(0)
    }
    
    return min + (num % range)
}

export fn generateNonce(length = 16) {
    return randomString(length)
}

export fn generateCSRFToken() {
    return base64URLEncode(randomBytes(32))
}

export fn generateAPIKey(prefix = "foo") {
    let randomPart = base64URLEncode(randomBytes(24))
    return prefix + "_" + randomPart
}

// üîç –ü—Ä–æ–≤–µ—Ä–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
export fn checkPasswordStrength(password) {
    let score = 0
    let feedback = []
    
    // –î–ª–∏–Ω–∞
    if password.length() >= 8 {
        score += 2
    } else {
        feedback.push("Password should be at least 8 characters long")
    }
    
    // –ó–∞–≥–ª–∞–≤–Ω—ã–µ –±—É–∫–≤—ã
    if password.match("[A-Z]") {
        score += 1
    } else {
        feedback.push("Password should contain uppercase letters")
    }
    
    // –°—Ç—Ä–æ—á–Ω—ã–µ –±—É–∫–≤—ã  
    if password.match("[a-z]") {
        score += 1
    } else {
        feedback.push("Password should contain lowercase letters")
    }
    
    // –¶–∏—Ñ—Ä—ã
    if password.match("[0-9]") {
        score += 1
    } else {
        feedback.push("Password should contain numbers")
    }
    
    // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
    if password.match("[!@#$%^&*()_+\\-=\\[\\]{}|;':\",./<>?]") {
        score += 2
    } else {
        feedback.push("Password should contain special characters")
    }
    
    let strength = "Very Weak"
    if score >= 7 {
        strength = "Very Strong"
    } else if score >= 5 {
        strength = "Strong"
    } else if score >= 3 {
        strength = "Medium"
    } else if score >= 1 {
        strength = "Weak"
    }
    
    return {
        "score": score,
        "strength": strength,
        "feedback": feedback
    }
}

export fn sanitizeInput(input, options = {}) {
    let maxLength = options["maxLength"] || 1000
    let allowHTML = options["allowHTML"] || false
    let allowSQL = options["allowSQL"] || false
    
    let sanitized = input.substring(0, maxLength)
    
    if !allowHTML {
        sanitized = sanitized.replace("<", "&lt;")
        sanitized = sanitized.replace(">", "&gt;")
        sanitized = sanitized.replace("\"", "&quot;")
        sanitized = sanitized.replace("'", "&#x27;")
    }
    
    if !allowSQL {
        let sqlKeywords = ["SELECT", "INSERT", "UPDATE", "DELETE", "DROP", "UNION", "OR", "AND"]
        for let keyword in sqlKeywords {
            let pattern = keyword.toLowerCase()
            if sanitized.toLowerCase().indexOf(pattern) >= 0 {
                return Err("Input contains potentially dangerous SQL keywords")
            }
        }
    }
    
    return Ok(sanitized)
}

// üé≤ –ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–∏—Ç–∏–≤—ã
export fn xor(data1, data2) {
    if data1.length() != data2.length() {
        return Err("Data lengths must be equal for XOR operation")
    }
    
    let result = ""
    for let i = 0; i < data1.length(); i++ {
        let char1 = data1.charAt(i).charCodeAt(0)
        let char2 = data2.charAt(i).charCodeAt(0)
        let xored = char1 ^ char2
        result = result + String.fromCharCode(xored)
    }
    
    return Ok(result)
}

export fn rotateLeft(value, positions) {
    // –ü—Ä–æ—Å—Ç–∞—è —Ü–∏–∫–ª–∏—á–µ—Å–∫–∞—è —Ä–æ—Ç–∞—Ü–∏—è –≤–ª–µ–≤–æ –¥–ª—è 32-–±–∏—Ç–Ω—ã—Ö —á–∏—Å–µ–ª
    let mask = 0xFFFFFFFF
    return ((value << positions) | (value >> (32 - positions))) & mask
}

export fn rotateRight(value, positions) {
    // –ü—Ä–æ—Å—Ç–∞—è —Ü–∏–∫–ª–∏—á–µ—Å–∫–∞—è —Ä–æ—Ç–∞—Ü–∏—è –≤–ø—Ä–∞–≤–æ –¥–ª—è 32-–±–∏—Ç–Ω—ã—Ö —á–∏—Å–µ–ª
    let mask = 0xFFFFFFFF
    return ((value >> positions) | (value << (32 - positions))) & mask
}

// üìä –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
export fn entropyAnalysis(data) {
    let frequency = {}
    let totalChars = data.length()
    
    // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —á–∞—Å—Ç–æ—Ç—É —Å–∏–º–≤–æ–ª–æ–≤
    for let i = 0; i < totalChars; i++ {
        let char = data.charAt(i)
        if frequency[char] == null {
            frequency[char] = 0
        }
        frequency[char] = frequency[char] + 1
    }
    
    // –í—ã—á–∏—Å–ª—è–µ–º —ç–Ω—Ç—Ä–æ–ø–∏—é
    let entropy = 0.0
    for let char in frequency {
        let p = frequency[char] / totalChars
        if p > 0 {
            entropy = entropy - (p * Math.log2(p))
        }
    }
    
    return {
        "entropy": entropy,
        "maxEntropy": Math.log2(Object.keys(frequency).length()),
        "uniqueChars": Object.keys(frequency).length(),
        "totalChars": totalChars,
        "randomness": entropy / Math.log2(256) // Normalized to 0-1
    }
}

// üîê –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
export let HASH_ALGORITHMS = ["md5", "sha1", "sha256", "sha512"]
export let HMAC_ALGORITHMS = ["hmac-sha256", "hmac-sha1", "hmac-md5"]
export let JWT_ALGORITHMS = ["HS256", "HS1"]

export let DEFAULT_BCRYPT_COST = 12
export let DEFAULT_PBKDF2_ITERATIONS = 100000
export let MIN_PASSWORD_LENGTH = 8
export let RECOMMENDED_KEY_LENGTH = 32

// üéØ –í–∞–ª–∏–¥–∞—Ç–æ—Ä—ã
export fn isValidHash(hash, algorithm) {
    let expectedLengths = {
        "md5": 32,
        "sha1": 40,
        "sha256": 64,
        "sha512": 128
    }
    
    if expectedLengths[algorithm] == null {
        return false
    }
    
    if hash.length() != expectedLengths[algorithm] {
        return false
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ hash —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ hex —Å–∏–º–≤–æ–ª—ã
    let hexPattern = "0123456789abcdefABCDEF"
    for let i = 0; i < hash.length(); i++ {
        if hexPattern.indexOf(hash.charAt(i)) < 0 {
            return false
        }
    }
    
    return true
}

export fn isValidBase64(data) {
    let base64Pattern = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
    
    for let i = 0; i < data.length(); i++ {
        if base64Pattern.indexOf(data.charAt(i)) < 0 {
            return false
        }
    }
    
    // Base64 –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∫—Ä–∞—Ç–µ–Ω 4 —Å–∏–º–≤–æ–ª–∞–º (—Å —É—á–µ—Ç–æ–º padding)
    return data.length() % 4 == 0
}

// üöÄ –í—ã—Å–æ–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
export fn createSecureSession() {
    return {
        "sessionId": randomUUID(),
        "csrfToken": generateCSRFToken(),
        "createdAt": now(),
        "expiresAt": timeAddHours(now(), 24)
    }
}

export fn encryptText(plaintext, password) {
    // –ü—Ä–æ—Å—Ç–æ–µ XOR —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–º –∫–ª—é—á–æ–º
    let key = sha256(password)
    let keyRepeated = ""
    
    // –†–∞—Å—à–∏—Ä—è–µ–º –∫–ª—é—á –¥–æ –¥–ª–∏–Ω—ã —Ç–µ–∫—Å—Ç–∞
    while keyRepeated.length() < plaintext.length() {
        keyRepeated = keyRepeated + key
    }
    
    keyRepeated = keyRepeated.substring(0, plaintext.length())
    let encrypted = xor(plaintext, keyRepeated)
    
    if encrypted.isOk() {
        return Ok(base64Encode(encrypted.unwrap()))
    } else {
        return encrypted
    }
}

export fn decryptText(ciphertext, password) {
    let decoded = base64Decode(ciphertext)
    let key = sha256(password)
    let keyRepeated = ""
    
    // –†–∞—Å—à–∏—Ä—è–µ–º –∫–ª—é—á –¥–æ –¥–ª–∏–Ω—ã –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
    while keyRepeated.length() < decoded.length() {
        keyRepeated = keyRepeated + key
    }
    
    keyRepeated = keyRepeated.substring(0, decoded.length())
    return xor(decoded, keyRepeated)
}