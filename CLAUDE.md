# Контекст проекта Foo Language

## Описание проекта
Интерпретируемый язык программирования с динамической типизацией, написанный на Go. Язык поддерживает базовые конструкции программирования и особую конструкцию `for-yield` для создания массивов.

## Структура проекта
```
foo_lang_v2/
├── ast/          # AST узлы и интерпретатор
├── lexer/        # Лексический анализатор
├── parser/       # Синтаксический анализатор
├── token/        # Определения токенов
├── value/        # Система типов
├── test/         # Тесты
├── examples/     # Примеры кода на Foo
└── main.go       # Точка входа
```

## Ключевые особенности

### 1. for-yield конструкция
Уникальная возможность создания массивов через циклы:
```foo
const squares = for let i = 1; i <= 5; i++ {
    yield i * i
}
// Результат: [1, 4, 9, 16, 25]
```

### 2. Проблема с областями видимости
Все переменные глобальные, хранятся в `value.Container`. Это создаёт проблемы:
- Переменные цикла конфликтуют между разными циклами
- Нет изоляции переменных в функциях
- Невозможно использовать одинаковые имена в разных контекстах

### 3. Система типов
- Все числа хранятся как `float64`
- Строки поддерживают escape-последовательности
- Массивы - это `[]any`
- Специальные флаги в `Value`: `isReturn`, `isBreak`, `isYield`

## Важные файлы

### ast/for_expr.go
Реализация for-yield с поддержкой:
- Обычных циклов for
- yield для сбора значений
- break для выхода
- Передача yield через вложенные конструкции (if внутри for)

### ast/print_expr.go
Кастомный форматтер для красивого вывода массивов:
```go
func formatValue(v any) string {
    switch arr := v.(type) {
    case []any:
        // Форматирование как [1, 2, 3]
    }
}
```

### value/value.go
Центральная структура для хранения значений с поддержкой:
- Различных числовых типов (конвертация в float64)
- Флагов состояния (isReturn, isBreak, isYield)
- Глобального контейнера переменных

## Известные проблемы

1. **Stack overflow при рекурсии** - функции вызывают переполнение стека
2. **Глобальные переменные** - нет локальных областей видимости
3. **print возвращает nil** - выводится в консоль как `<nil>`

## Последние изменения

1. Исправлен вывод массивов (было `[3 4]`, стало `[3, 4]`)
2. Добавлена поддержка yield через вложенные конструкции
3. Исправлена поддержка break в циклах
4. Добавлены escape-последовательности в строках
5. Написаны тесты для for-yield

## Команды для разработки

```bash
# Запуск интерпретатора
go run main.go

# Запуск тестов
go test ./test/... -v

# Запуск конкретных тестов
go test ./test/... -v -run TestForYield
```

## Соглашения о коде

1. Все AST узлы в пакете `ast` реализуют интерфейс `Expr`
2. Метод `Eval()` возвращает `*Value`
3. Специальные состояния (return, break, yield) передаются через флаги в `Value`
4. Парсер использует рекурсивный спуск
5. Токены определены как константы в `token/token.go`

## Правила для AST узлов

### Каждый AST узел должен:
1. **Делать только одну вещь** - один узел = одна операция
2. **Быть максимально простым** - минимум кода, максимум читаемости
3. **Иметь понятное имя** - сразу ясно, что делает
4. **Минимум полей** - только необходимые данные

### Пример хорошего AST узла:
```go
type AddExpr struct {
    Left  Expr
    Right Expr
}

func (a *AddExpr) Eval() *Value {
    left := a.Left.Eval()
    right := a.Right.Eval()
    return NewValue(left.Float64() + right.Float64())
}
```

### Плохо:
- Смешивать логику (например, и сложение, и вычитание в одном узле)
- Сложные условия и ветвления
- Много вложенных проверок

## Следующие шаги

См. файл TODO.md для списка задач и известных проблем.